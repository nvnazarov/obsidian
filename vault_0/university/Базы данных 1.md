# (13.09.24) Л1

Ссылочная целостность данных (Referential Integrity)

Flat-file database (.csv, for search and update DBMS read whole file)
Issues:
- Expandability, compatibility
- Data integrity
- Durability
- Transactions
- Efficient search and data modifications

DBMS is software that allows applications to store and analyze information in a DB.
General-purpose DBMS supports the definition, creation, querying, update and administration of DBs in accordance with some _data model_.

Data model - collection of concepts for describing data in a DB.
Examples:
- Relational
- NoSQL (Key/Value, Hierarchical Graph, Document/XML/Object)
- Array/Matrix/Vector (ML)
Schema - description of a particular collection of data, using a given data model.

SQL -> NoSQL -> NewSQL/DistributedSQL

Databases by type of load:
- OLAP - Online Analytical Processing
- OLTP - Online Transactional Processing
- HTAP - Hybrid Transactional/Analytical Processing

ACID properties:
- Atomicity
- Consistency
- Isolation
- Durability

Isolation level and read phenomena:

| Level            |     |     |     | Phantom read |
| ---------------- | --- | --- | --- | ------------ |
| Read uncommitted |     |     |     |              |
| Read committed   |     |     |     |              |
| Repeatable read  |     |     |     |              |
| Snapshot         |     |     |     |              |
| Serializable     |     |     |     |              |

Logical level - the level of entities, their connections and attributes.
Physical level - the level of data storage on the disk.

## Relational data model

Relational data model aspects:
- Structural
- Integrity
- Manipulation

Relation - unordered set of relationships of attributes that represent entities.
Tuple - set of attributes in a relation.
Attribute - name associated with a domain (data type).

n-ary relation - relation with n columns.

Primary key - uniquely identifies a tuple in a relation.
Foreign key 

Constraints:
- Referential
- Unique key
- Predicate

## Relational algebra

Operators:
- Select
- Projection
- Union
- Intersection
- Difference
- Product
- Join

Additional:
- Rename
- Aggregation
- Sorting
- Duplicate elimination
- Assignment
- Division
# (13.09.24) С1

Minimum language syntax: SQL-92
2016 - JSON support
2019-2020  - Multidimensional arrays
2023 - Property Graph Queries

DDL
DML

`explain ...`

Filters: `where`

Pagination:
- `offset + limit` - bad idea
- `where + order by + limit`

`having` - как `where`, но после `group by`

Window functions:
`... over (partition by ...)`

Joins:
`cross join`, `inner join`, `left join`, `left semi join`, `left anti join`
`lateral`

Cte:
`with t(c,...) as (...)`
`with recursive`
# (20.09.24) Л2 - Storage 1

Disk-oriented DB architecture
## Storage Hierarchy

faster, smaller, expensive
volatile, random access byte-addressable
- Devices closest to the CPU (registers, etc.)
- CPU caches L1, L2, L3
- DRAM

non-volatile sequential-access block-addressable
- SSD
- HDD
- Network Storage
slower, larger, cheaper
## Storage latency

1. 0.5ns L1 cache reference
2. 7ns L2 cache reference
3. 100ns DRAM (can be more when access to different NUMA node)
4. 150.000ns SSD
5. 10.000.000ns HDD
6. ~30.000.000ns Network Storage

SATA SSD ~600 MB/s
NVME SSD ~3.5GB/s
## DBMS Storage Components

Manage the movement of data between non-volatile and volatile memory.
The system cannot work with data directly on disk without first moving it to volatile storage.

`mmap`

`madvice` - tells OS the subsequent page reading strategy
`mlock` - tells OS that a range of pages cannot be swapped out of memory
`msync` - tells OS to synchronize a range of pages (write to disk)

OS cannot effectively understand which pages need to be flushed on disk, and which should be kept in memory for subsequent access.

A DBMS can do this more efficiently:
1. The correct order for flushing pages to disk
2. Preloading data (prefetch)
3. Resource IO scheduling
4. Cache policy is difficult to manage

[Are You Sure You Want to Use MMAP in Your Database Management System? (cidrdb.org)](https://www.cidrdb.org/cidr2022/papers/p13-crotty.pdf)
## File Storage

The DBMS stores the DB in the form of one or more files on disk
## Storage Manager

Responsible for storing DB files

1. Organize files as a set of pages
2. Tracking reading/writing data to pages
3. Monitoring of available space
4. May be responsible for scheduling reads and writes, improve data locality on pages

DBMS Page - block of data of a fixed size (usually 512B - 16KB).
Page can contain tuples, metadata, indexes, WAL records.
Each page is assigned a unique identifier.
The DBMS uses an indirect layer to map page identifiers to their physical location on disk.
## Page Storage Architecture
### Heap File

Heap file - an unordered set of pages where tuples are stored in random order.
- Linked List
	Header page at the beginning of the file, which stores HEADs of the list of free pages and pages filled with data. Each page itself tracks the number of free slots.
- Page Directory
	

![[(img) DBMS Page Storage Linked List.png]]![[(img) DBMS Page Storage Page Directory.png]]

### Page Layout

Header with metadata:
- Page size
- Checksum
- DBMS version
- Transaction visibility
- Compression information

| Header |
| :----: |
|  Data  |
### Tuple Storage

1. Tuples are stored one after another, header stores number of tuples.
	Problem: after deleting tuple we have to move the ones after the tuple
2. Slotted pages

![[(img) DBMS Page Storage Slotted Pages.png]]
### Tuple Layout

A sequence of bytes, DBMS task is to interpret it.

Has a header with metadata:
- Transaction visibility metadata
- Bit mask for null values

Each tuple is assigned a unique record ID. Usually this is `page_id` + offset/slot. May also contain info about the location of the file.

Postgres: `table.ctid`
### Data Types

- Integers (INTEGER, BIGINT, SMALLINT, TINYINT)
- Variable Precision Numbers (FLOAT, DOUBLE/REAL)
- Fixed Precision Numbers (NUMERIC, DECIMAL)
- Fixed Length Data - fixed length byte array (CHAR)
- Variable Length Data - byte array of arbitrary length (VARCHAR, VARBINARY, TEXT)
- External Value Data - tuple as an external file (BLOB)
- Dates and Times (TIME, DATE, TIMESTAMP)
- Additional Types (ENUM, Arrays, Geometric types, Composite Types, JSON/XML, Range)

Most DBMSs do not allow a tuple to be larger than one page. They solve this problem by moving value to the overflow page, and place in the tuple a pointer to the value on overflow page.

Postgres: TOAST (>1/4 page size)
MySQL: Overflow (>1/2 page size)
## System Catalog

The DBMS stores metadata about DBs in its system directories.

1. Tables, Views, Columns, Attributes, Indexes
2. Users, Access rights

Most DBMSs store metadata in special system tables.
# (20.09.24) С2 - Storage в Postgres

Books: "PostgreSQL 16 Изнутри"

`select oid, relname from pg_class;` - все таблицы Postgres.
`hexdump -C <file>`

Write Head Log

Команды `psql`:
- `checkpoint` - применяет все, что записано в Write Head Log.
- `vacuum` - что-то вроде сборщика мусора в `psql` - удаляет неиспользуемые данные (кортежи) на страницах.

Как хранятся страницы:
- `<page_id>`
- `<page_id>_fsm` - free space map
- `<page_id>_vm` - visibility map
## Структура версии кортежа

Заголовок + данные.

Заголовок содержит множество полей, например:
- `xmin`, `xmax` - номера транзакций (предыдущая и текущая)
- `infomax`
# (27.09.24) Л3 - Storage 2

## Overview

![[(img) DBMS Buffer Pool.png]]

Spatial control - where to write pages on disk. The goal is to keep pages that are frequently used together physically as close to each other on disk as possible.

Temporal control - when to read pages into memory and when to write them to disk. The goal is to minimize the number of stalls when reading data from disk.
## Buffer pool

Пространство в памяти, куда можно записывать данные страниц.

Organization:
- A fixed-size array;
- The array element is called a frame;
- When the DBMS request a page, an exact copy of it is placed in one of these frames.
## Page table

Keeps track of the pages that are currently in memory.
Usually implemented as fixed-size hash table protected with latches to ensure thread-safe access.

Supports additional metadata per page:
- Dirty flag;
- Pin/reference counter;
- Access tracking information.
## Page directory

Mapping of page IDs to the location of pages in database file.
All changes must be written to disk so that the DBMS can read the page layout when restarted.
## Locks

Protects the logical contents of the database from other transactions.
Hold for the duration of the transaction.
It should be possible to rollback changes.
## Latches

Protects critical sections of the DBMS internal data structure from other threads.
Hold for the duration of the operation.
You don't need to be able to rollback changes.
Similar to mutex.
## Allocation policies

Global policies:
- Make decisions for all active transactions.

Local policies:
- Allocate pages for a specific transaction, without taking into account the behavior of concurrent transactions;
- It is necessary to support the exchange of pages.
## Buffer pool optimizations

- Use multiple buffer pools (for example one for each table, for each transaction);
- Prefetch;
- Scan sharing - use scanning of another request;
- Buffer pool bypass - read bypassing the buffer pool.
### Prefetch

The DBMS can also perform page prefetching based on the query plan.

1. Sequential scan;
2. Index scan.
### Scan sharing

Queries can reuse data retrieved from storage or computed by operators. This is different from caching query results.

Allow multiple queries to attach to a single cursor that scans the table.
- The requests do not have to be the same;
- It is possible to exchange intermediate results.

Supported in IBM DB2, MSSQL.
### Buffer pool bypass

The sequential scan operator will not store fetched pages in the buffer pool to avoid overhead.

- Works well if the operator needs to read a large sequence of pages located side by side on disk;
- Can be used for temporary data (sorting, merging).
## OS Page Cache

Most disk operations go through the OS API. Unless you disable it, the OS maintains its own file system cache (page cache).

Most DBMSs use direct I/O (O_DIRECT) to bypass the OS cache.
- We get rid of redundant copies of pages;
- We can support various eviction rules.

[os page cache]
## Buffer replacement policies

When the DBMS need to free a frame to make room for a new page, it must decide which page to exclude from the buffer pool.

Goals:
- Correctness;
- Accuracy;
- Speed;
- Metadata overhead.

[page replacement algorithms]
[cache replacement policies]
### LRU

Keep a timestamp of when each page was last accessed.
When the DBMS needs to evict a page, it should select the page with the oldest timestamp.
You can store pages in order sorted by access timestamp to reduce search time during eviction.
### Clock

LRU approximation without the need for a separate timestamp per page.

- Each page has a reference bit (or counter).
- When accessing a page, set the bit value to 1.
- The pages are organized in a ring buffer, we iterate around the pages clockwise.
- During the traversal, we check whether the value of the page bit is equal to 1. If yes, we reset it to 0. If not, we evict the page.
### Sequential flooding

LRU and CLOCK replacement policies are subject to sequential flooding.

The request performs a sequential scan that reads each page.
This pollutes the buffer pool with pages that are read once and never again.
The last page used is actually the most unnecessary page.
### LRU-K

DBMS track the history of the last K page requests.
LRU-K evicts the page whose Kth last access is the furthest in the past.

For example, LRU-1 is just an LRU, while LRU-2 evicts pages according to their second-to-last access time.
### Advanced policies

- Redis LRU approximation;
- ARC (Adaptive Replacement Cache) - patented by IBM.
### Locality

The DBMS selects which pages to evict depending on their locality relative to the transaction and queries.
Keeps track of the pages accessed by request.
### Priority hints

The DBMS knows what the context of each page is at the time the query is executed.
The DBMS can give hints to the buffer pool about whether a page is important or not.
## Dirty pages

If the page in the buffer pool is not dirty, then the DBMS can simply evict it.
If the page is dirty, the DBMS must write back to disk to ensure its changes are saved.
### Background writing

The DBMS can periodically scan the page table and write dirty pages to disk.

When a dirty page is safely written, the DBMS can either evict the page or simply clear the dirty flag.

Need to be careful not to write dirty pages before write to WAL.
## Disk I/O scheduling

OS/hardware tries to maximize disk bandwidth by reordering and batching I/O requests.
But they don't know which I/O requests are more important than others.
DBMS can maintain a read/write requests queue for each request, to provide better requests scheduling.
Most DBMSs use direct I/O (O_DIRECT) to bypass the OS cache.
## Other memory pools

DBMS needs memory not only for tuples and indexes, but also for other things.

These other memory pools can be either in main memory or stored on disk. Depends on implementation.
- Sorting + merging buffers;
- Query result caches;
- Maintenance buffers;
- WAL buffers.
# (27.09.24) С3 - Buffer pool в Postgres

В терминологии PostgreSQL - Buffer manager.

[8. Buffer Manager :: Hironobu SUZUKI @ InterDB](https://www.interdb.jp/pg/pgsql08.html)

`create extension pg_buffercache;`
# (04.10.24) Л4 - Log-structured Storage

Plan:
- Log-structured storage organization;
- Index organized storage;
- OLTP, OLAP, HTAP workloads;
- NSM storage model (row store);
- DSM storage model (column store).
## Slotted pages

Issues:
- Fragmentation;
- Useless Disk I/O (Read/write amplification);
- Random Disk I/O;
- Object storages (S3, HDFS).
## Log-structured file organization

The DBMS appends new log entries to an in-memory data structures and when data structure size is greater than some limit writes data to disk.

Log-structured Merge-Tree (LSM-Tree)

Instead of storing tuples on pages, the DBMS stores only log records. The system adds log entries to the file about how the database was changed:
- `INSERT` saves the entire tuple;
- `DELETE` marks tuple as deleted;
- `UPDATE` contains only attributes that have changed (or whole updated tuple).

On each page data is almost always sorted by PRIMARY KEY called Sorted String Tables (SSTables). Various indexes can improve reading performance (sparse index, hash, bloom filter, cuckoo index).

Periodic compaction of log files (delete unnecessary logs). Different compaction strategies:
- Universal compaction;
- Level compaction.

Examples: LevelDB, RoomsDB.
## Database workloads

- OLTP (Many transactions which read small data chunks - online shopping, banks);
- OLAP (Transactions read huge data chunks);
- HTAP (Hybrid).
## N-ary storage model (NSM)

Row store.
The DBMS stores all attributes of one tuple sequentially on the page.
Ideal for OLTP workloads where queries typically modify single objects.

Advantages:
- Quick insert, update and delete;
- Suitable for queries that require the entire tuple.

Disadvantages:
- Not suitable for scanning large portions of a table and/or subset of attributes.

Examples: MySQL, Oracle.
## Decomposition storage model (DSM)

Column store.
The DBMS stores the values of one attribute for all tuples sequentially on the page.
Ideal for OLAP workloads where read-only queries perform large scans on a subset of table attributes.

Advantages:
- Reduces unnecessary I/O operations because the DBMS reads only the data it needs;
- Improved query processing and data compression.

Disadvantages:
- Slow for point queries, inserts, updates and deletions due to the fact that the data of one tuple is located in different pages.

Examples: Vertica, VectorWise, MonetDB, ClickHouse.
# (04.10.24) С4 - Parsers & Interpreters

Plan:
- Front-ends Overview;
- Lexers;
- Ragel;
- Parsers;
- Predictive Parsing;
- LR Parsers;
- Bison;
- Conflicts in Bison;
- Evaluation;
- Optimizations;
- Stack Machines.
## A model of a compiler front-end

`source program` -> Lexical Analyzer -> `tokens` -> Parser -> `syntax tree` -> Code Generator -> `code`

Use Ragel to generate lexer:
...
## Regular Expressions

https://swtch.com/~rsc/regexp/regexp1.html
https://dl.acm.org/doi/10.1145/363347.363387

...

RE and NFAs.
## Parsers

Context-free grammar:
- Set of terminal symbols (tokens);
- Set of nonterminals;
- Set of productions;
- Start symbol.

BNF - Backus-Naur form.
Ambiguous grammars.
### Parsing

Top-down
Bottom-up

https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.html

LR Parsers

Bison
## Optimizations

- Constant folding;
- Algebraic simplification;
- Value numbering (https://dl.acm.org/doi/10.5555/1177220);
- Short-Circuit Evaluation.