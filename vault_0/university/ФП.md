# (10.09.24) Л1

## Intro to functional programming

Punch Cards > Machine Code > Assembly Language > FORTRAN.

| Programming paradigm       | Algorithmic Model                                                 | Programming Languages |
| -------------------------- | ----------------------------------------------------------------- | --------------------- |
| Imperative                 | Turing Machine                                                    | FORTRAN, C#, C++      |
| Functional (Applicative)   | Lambda-Calculus                                                   | LISP, F#, Scala       |
| Logic (Declarative)        | First-Order Predicate Logic Resolution Algorithm and Horn clauses | Prolog, Mercury, Oz   |
| Situational (Productional) | Normal Markov Algorithms                                          | Refal                 |
Main ideas of functional programming:
- A Problem solution is a function, which takes some input parameters and produces output;
- A Solution is a composition of other (simpler) functions;
- There are no variables that can change their value;
- Functions are first-class citizens, and can be manipulated upon.

Most important to know:
- Based on sound math theory - Lambda-Calculus;
- Execution of a program is a step-by-step simplification (reduction);
- No variables means no side effects, possibility of effective parallelization and less bugs;
- Close to math means one can reason about programs and program is easier to understand.

To basic operations in functional programming:
- Application (apply function to arguments and get result);
	`1+2` gives `3`
- Abstraction (an anonymous function).
	`(fun x->x+2)`

$\alpha$-conversion - `fun x->x+2` to `fun y->y+2`.
$\beta$-conversion - apply abstraction to application.
$\beta$-reduction - if $\beta$-conversion reduces the function.
## F\#

https://fharp.org

Options to run F# program:
- Compile as EXE and run;
- Run as script.

This:

```fsharp
let add2 = fun x->x+2
in add2 1
```

is syntax sugar for:

```fsharp
(fun add2 -> add2 1) (fun x->x+2)
```

Can also write:

```fsharp
let add2 x = x+2
```

Composition:

```fsharp
let twice x = x*2

twice twice 2  // incorrect
twice (twice 2)
2 |> twice |> twice
twice <| 2 |> twice
(twice >> twice) 2
(twice << twice) 2
```

Functions of multiple arguments:

```fsharp
// with tuple
let bad_plus (x,y) = x+y
bad_plus (1,2)

let plus x y = x+y // int -> int -> int
plus 1 2

// same as
let plus = fun x -> fun y -> x+y
```

Currying - every function is a function of one argument, but it can return another function.
# (17.09.24) Л2
## Typing

Lambda-Calculus is a typeless theory (`(lz.z z)(lz.z z)`).

Programming languages:
- Strong static typing;
- Type inference.

```fsharp
let inline plus x y = x+y  // 'polymorphic'
plus 1. 2.
plus 1 2
```

Types:
- Base types (`int`, `float`, `string`);
- Functional types $T_1 \rightarrow T_2$;
- Tuples $T_1 \cdot T_2$;
- Discriminated union $T_1 + T_2$;
- Algebraic Data Types.

```fsharp
// discriminated union
type IntOrStr =
|	Int of int
|	Str of string

let x = Int 1

match x with
	| Int i -> ...
	| Str s when (s = "") -> ...
	| Str s -> ...

// named tuple
type Person = { Name: string; Age: int }

type DocumentInfo =
	| Passport of int
	| DriverLicense of string

// tuple
type Person = string * int * DocumentInfo
let vasya = "Vasya", 25, Passport 123
let (name, age, doc) = vasya

// type 'a option = None | Some of 'a
let solve a b c =
	let d = b*b - 4.*a*c
	if d < 0 then None
	else
		let x1 = 
		let x2 = 
		Some (x1, x2)
```

```fsharp
// can't have pattern matching,
// but can have multiple args
let f = fun x y -> x*y+2

// can have pattern matching,
// but can't have multiple args
let f = function 1 -> "One" | 0 -> "Zero" | _ -> "A lot"
```
## Recursion

```fsharp
let rec print a b =
	if a<b then
		printf "%d " a
		print (a+1) b
print 1 10
```

```fsharp
for x in 1..10 do ...
```

Every function must return something, by default it's `unit` (which is exactly `()`).

Recursion problem:

```fsharp
// here we first go deeper into recursion and
// than multiply by the number - so we need to
// remember the stack of calls
let rec fact = function
	|x when x=1I -> 1I
	|x -> x*fact(x-1I)

// here we don't need to remember the stack,
// because we can just return `acc` when
// recursion approaches its deepest point
//
// so, it can be rewritten as a loop
let rec fact' acc = function
	|x when x=1I -> acc
	|x -> fact' (acc*x) (x-1I)
```

_Tail recursion_: all computation is done before calling recursion.
- Add accumulator as an extra parameter;
- Return accumulator upon recursion termination;
- Embrace inner function with accumulator within main function.

```fsharp
// before
let rec fact = function
	|x when x=1I -> 1I
	|x -> x*fact(x-1I)

// after
let rec fact =
	let rec fact' acc = function
		|x when x=1I -> acc
		|x -> fact' (acc*x) (x-1I)
	fact' 1I
```
## More on reduction

Parts that are being reduced are called _redex_.

```
			 inner redex
		  |---------------|
(lx.ly.y)((lz.z z) (lz.z z))
|--------------------------|
        outer redex
```

When we compute outer regex, its called _call by name_, and corresponds to lazy computations.
When we compute inner regex (argument), its called _call by value_, or eager computations.

Reduction order is important!

Reduction order:
- Applicative reduction (AR) - leftmost of the inner redexes is reduced;
	Eager computations, more effective in implementation.
- Normal reduction (NR) - leftmost of the outer redexes is reduced.
	Lazy computations, hard to implement useful side effects (I/O).

_Standardization theorem_: if expression can be reduced, it can be reduced lazily.

Lazy computations guarantee that all expressions are reducible, but in NR same expression could be computed twice or more - _split problem_:

```
(lx.x + x)(2 + 3)
AR: (lx.x + x) 5 -> 5 + 5 -> 10
NR: (2 + 3)(2 + 3) -> 5 + (2 + 3) -> 5 + 5 -> 10
```

Several techniques to avoid split problem:
- Memoization;
- Computation with context;
- Graph reduction.
# (24.09.24) Л3
## Recursion in Lambda-Calculus

Recursion can be used if we have naming. Lambda-Calculus has only anonymous functions. 

Naming construction is just a syntactic sugar:

```fsharp
// same as:
// (lx.expr2) expr1
let x = expr1
in expr2
```
## Fixpoint

`fact = F fact` - `fact` is called a _fix point_ of `F`.

Consider fix point operator `Y` such that `Y f = f(Y f)`. In F#, we can define it as:

```fsharp
let rec fix f x = f (fix f) x
```

Now, factorial can be defined as:

```fsharp
let fact = fix(fun f -> fun x -> if x = 0 then 1 else x * f (x - 1))
fact 5  // 120
```

Function can have many fixpoints (`lx.x` has infinite), `Y` returns least fixpoint.
`Y = lh.(lx.h(x x)) (lx.h(x x))`.
## Combinators

Question: can we create calculus without variables? Yes, based on combinators. 

_Combinator_ - lambda-expression without free variables.
Examples:
- Y - fixpoint operator (`lh.(lx.h(x x)) (lx.h(x x))`)
- I - identity function (`lx.x`)
- K - constant function, cancelator (`lx.ly.y`)
- S - distributor (`lf.lg.lx.f x (g x)`)
- (others)

Any function can be expressed by using combinators.

_Basis_ - a minimal set of combinators that can be used to express functions (example: S K).
# (01.10.24) Л4 - Simplest ADTs

How to read input:

```fsharp
read_int() = Int32.Parse(Console.ReadLine())

let x = read_int ()

```
## Lists

В функциональных языках используются рекурсивные структуры данных - списки, деревья.

```fsharp
type 't list = Nil | Cons of 't*'t list

let x = Cons(1, Cons(2, Cons(3, Nil)))
```

Built-in lists:

```fsharp
// type 'a list =
// | ([])
// | (::) of 'a * 'a list

1::2::3::[]
[1;2;3]
let h::t = [1;2;3]
```
## Базовые функции обработки списков
### Fold & Reduce

`List.Fold f list`
`List.Reduce f list`

```fsharp
let rec fold f i = function
	| [] -> i
	| h::t -> f h (fold f i t)

let rec reduce f = function
	| [] -> failwith "Cannot reduce"
	| [x] -> x
	| h::t -> f h (reduce f t)
```
### Map

```fsharp
let rec map f = function
| [] -> []
| h::t -> (f h)::(map f t)
```
### Filter

```fsharp
let rec filter p = function
| [] -> []
| h::t when p h -> h::(filter p t)
| _::t -> filter p t
```
### Scan

`map` + `fold`
### Стандартная библиотека

`List.map`, `List.mapi`, `List.map2`, `List.mapi2`, `List.map3`
`List.filter`
`List.fold`, `List.foldBack`, `List.reduce`
`List.iter`
`List.head`, `List.tail`, `List.nth`
`List.sum`, `List.sumBy`
`List.sort`, `List.sortBy`

`List.choose` - `map` + `filter`
`List.pairwise`
`List.find`, `List.tryFind`
`List.findIndex`, `List.tryFindIndex`
`List.forall`, `List.exists`
`List.zip`, `List.unzip`
`List.take`, `List.takeWhile`
### Конкатенация списков

`O(n)`

```fsharp
[1;2]@[3;4]
```

`List.concat`, `List.collect`
## Quicksort

`List.partition` - разбить список на два по предикату.

```fsharp
let rec qsort = function
	| [] -> []
	| x::xs ->
		let (l,r) = List.partition ((>)x) xs
		qsort l @ x::(qsort r)
```
## List comprehension

```fsharp
List.init 9 (fun x -> 2.0 ** (float x))

[ for x in 0..8 -> 2.0 ** (float x) ]
[ 1..10 ]
[ 1..2..10 ]
[ for x in 1..10 do if x % 3 = 0 then yield x ]
```
## Monoids

Моноид - (M, @, e)
- M - область определения (множество);
- @ - бинарная ассоциативная операция на M;
- e - единичный элемент в M.

> (int, +, 0), (int * 1)
> (списки, @, \[\])
> ({f: A->A}, композиция, id)

Гомоморфизм моноидов
Списочный гомоморфизм - гомоморфизм из моноида (списки, @, \[\]) в другой моноид.

> `hom(+, lx.1, 0)` - списочный гомоморфизм.
### Теоремы о гомоморфизме

1. (MapReduce) Любой списочный гомоморфизм можно представить в виде композиции `map` и `reduce`;
2. Любой списочный гомоморфизм выражается в виде левой и правой сверток;
3. Функция из списочного моноида, выразимая в виде левой и правой сверток, является списочным гомоморфизмом.
## Arrays and Matrices

```fsharp
type image = char list list
```

Массивы - императивная составляющая языка F#.

`Array.*` - те же функции, что и для `List.*`.

Дополнительные операции:
- Mutability: `A.[n] <- z`;
- Slicing: `A.[1..5]`, `A.[1..5] <- [|1..5|]`;
### Представление матриц

- Список списков `type 'a matrix = 'a list list`;
- Массив массивов Jagged array `type 'a matrix = 'a [][]`;
- Двумерный массив `type 'a matrix = 'a [,]`;
- Разрезженное представление.
### Встроенные типы

```fsharp
#r "FSharp.PowerPack.dll"

let m = Matrix.ofList [[1;2];[3;4]]
m.Transpose
m.Row(1)
```
### Типы .NET Framework

- `Dictionary<T1,T2>`;
- `ResizeArray` - `List<T>` в .NET Framework.