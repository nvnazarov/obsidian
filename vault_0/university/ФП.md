# Лекция 1 (10.09.24)
# Лекция 2 (17.09.24)

Typing:
Lambda calculus is a typeless theory (`(lz.z z)(lz.z z)`)

Programming languages:
- strong typing
- type inference

Types:
- Base types (`int`, `float`, `string`)
- Functional types $T_1 \rightarrow T_2$
- Tuples $T_1 \cdot T_2$
- Discriminated union $T_1 + T_2$
- Algebraic Data Types

```fsharp
type IntOrStr =
	Int as int
	Str as string

match x with
| Int i -> ...
| Str s when (s = "") -> ...
| Str s -> ...

type Person = string * int * IntOrStr
let vasya = "Vasya", 25, "..."
let (name, age, k) = vasya

// type 'a option = None Some of 'a
let solve a b c =
	let d = b*b - 4.*a*c
	if d < 0 then None
	else
		let x1 = 
		let x2 = 
		Some(x1, x2)
```

```fsharp
// can't have pattern matching,
// but can have multiple args
let f = fun x y -> x*y+2

// can have pattern matching,
// but can't have multiple args
let f = function 1 -> "One" | 0 -> "Zero" | _ -> "A lot"
```

Recursion:

```fsharp
let rec print a b =
	if a<b then
		printf "%d " a
		print (a+1) b
print 1 10
```

```fsharp
for x in 1..10 do ...
```

_Tail recursion_: all computation is done before calling recursion

Reduction order:
- Applicative reduction
- Normal reduction

Standardization theorem

Eager and lazy programming languages